#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jan 13 10:37:11 2021

Class to read GMI simulations generated by ARTS
Can read in either one file or a list of files

@author: inderpreet
"""


import scipy.io
import numpy as np
import matplotlib.pyplot as plt
from iwc2tb.py_atmlab.apply_gaussfilter import apply_gaussfilter
import zipfile
from typhon.arts import xml
from scipy import interpolate
import os
import glob
from iwc2tb.common.add_gaussian_noise import add_gaussian_noise
from iwc2tb.py_atmlab.gaussfilter import filter_stype

class GMI():
      
    
    def __init__(self, filenames):
        """
        Class to read GMI simulations generated by ARTS
        ----------
        filenames : string/list of strings containing the filename(s)

        Returns
        -------
        None.

        """
        self.nedt = np.array([0.70, 0.65, 0.47, 0.56 ])
        
        if np.isscalar(filenames):
#            print ('doing only one file')
            filenames = [filenames]
        self.files = filenames    
        self.mat = []
        for file in filenames:
            self.mat.append(scipy.io.loadmat(file))
            

    def get_inputfiles(self):
        """
        Generates the names of input DARDAR-ERA zipfiles

        Returns
        -------
        list containing DARDAR-ERA zip files

        """
        
        inputfiles = []
        for file in self.files:
            zfile = file.replace(".mat", ".zip")
#           zfile = zfile.replace("GMI_m65", "DARDAR_ERA_m65")
            fname = os.path.basename(zfile)
            zfile = os.path.join("/home/inderpreet/Dendrite/Projects/IWP/GMI", "DARDAR_ERA_m65_p65_zfield", fname)

            inputfiles.append(zfile)
        return inputfiles    
      
    def get_lsm(self):  
        """
        reassigns the surface types

        Returns
        -------
        data : the reclassfied surface types.
        
        0 - water
        1 - land
        2 - snow
        3 - sea-ice
        4 - coastline
        5 - snow/water boundary
        6 - water/sea-ice boundary
        7 - snow/land boundary
        8 - land/sea-ice boundary
        9 - snow/sea-ice boundary        

        """

        data = []
        inputfiles = self.get_inputfiles()        
        for i, infile in enumerate(inputfiles):

            with zipfile.ZipFile(infile, 'r') as zf:
                for file in zf.namelist():

                    if file.endswith("lsm.xml"):
                        zf.extract(file, "/home/inderpreet/data/temp")
                    if file.endswith("lat_grid.xml"):    
                        zf.extract(file, "/home/inderpreet/data/temp")
               
                
            lsm0 = np.squeeze(xml.load("/home/inderpreet/data/temp/lsm.xml"))
            lat0 = np.squeeze(xml.load("/home/inderpreet/data/temp/lat_grid.xml"))
            
            for f in glob.glob("/home/inderpreet/data/temp/*.xml"):
                os.remove(f)
                
            mat = self.mat[i]
            stype = np.squeeze(mat["B"]["stype"][0,0])
            lat   = np.squeeze(mat["B"]["lat"][0, 0])

            f     = interpolate.interp1d(lat0, lsm0, kind = "nearest")                    
            lsm   = f(lat)

            iland         = lsm > 0.5
            isea          = lsm <= 0.5
        
        
            lsm[iland]  = 1
            lsm[isea]   = 0            
            
            # reassign sea-ice to stype = 3
            ix = (lsm == 0) & (stype == 2)              
            stype[ix] = 3
            
            # reassign stype on land/ocean/snow/ice boundaries
            stype_all = filter_stype(lat, stype )

            data.append(stype_all)

        return data     
        
    def get_data(self, parameter):    
        """
        method to read in the data from *.mat file   
    
            Parameters
        ----------
        parameter : string containing name of the parameter to be extracted

        Returns
        -------
        data : np.array of requested data

        """
        allparameters = ("[Tb, iwp, lat, lon, pos, stype, z0, p0, t0, rwp, wvp,"
                            "incang, e166h, e183h, e166v, e183v]")
        
        if parameter not in ["Tb", "Ta", "iwp", "lat", "lon", "pos" ,
                              "stype", "z0", "p0", "t0", "rwp", "wvp",
                              "t2m", "tskin", "incang", "e166h", "e183h",
                              "e166v", "e183v"]:
            raise ValueError(f"parameter should be one of {allparameters}")
            
        data = []    
        if parameter == "Tb":
            for i in range(len(self.mat)):
                mat = self.mat[i]
                tb  = mat["Tb"]
                data.append(tb)
            return data
        
        elif parameter == "Ta":
            for i in range(len(self.mat)):
                mat = self.mat[i]
                tb  = mat["Tb"]
                lat = mat["B"]["lat"][0, 0]
                ta = GMI.get_ta(tb, lat)
                data.append(ta)
            return data
        
        elif parameter == "stype":
            return self.get_lsm()
        
        elif parameter in ["iwp", "z0", "t0", "rwp", "wvp", "t2m", "tskin"]:
             for i in range(len(self.mat)):
                mat = self.mat[i]
                var = mat["B"][parameter][0,0]
                lat = mat["B"]["lat"][0, 0]
                var = apply_gaussfilter(lat, var, 6/111)# 6km smoothing
                data.append(var)    
             return data  
         
        elif parameter in ["incang", "e166h", "e183h", "e166v", "e183v"]:
            for i in range(len(self.mat)):
                mat = self.mat[i]
                var = mat["S"][parameter][0,0]
                lat = mat["B"]["lat"][0, 0]
                var = apply_gaussfilter(lat, var, 6/111)# 6km smoothing
                data.append(var)    
            return data  
        else:
            for i in range(len(self.mat)):
                mat = self.mat[i]
                data.append(mat["B"][parameter][0,0])
            return data
        
        
    def get_O(self, parameter):
        """
        method to read in ARTS setup inputs

        Parameters
        ----------
        parameter : string containing the name of the input to be extracted

        Raises
        ------
            valueError if the parameter is not in the list 
            
        Returns
        -------
        data : list of arrays containing the parameter desired

        """
        allparameters = "[icehabit, icepsd, icesize, rainpsd, lsampling, pratio_csat, pratio_gmi, phase_tlim]"
        if parameter not in ["icehabit", "icepsd", "icesize", "rainpsd", "lsampling" ,
                              "pratio_csat", "pratio_gmi", "phase_tlim"]:
            raise (ValueError(f"parameter should be one of {allparameters}"),)
        data = []
        for i in range(len(self.mat)):
                mat = self.mat[i]
                data.append(mat["O"][parameter][0,0])
        return data                      
    
    @staticmethod   
    def get_ta(tb, lat):
        """
        Get antenna weighted brightness temperature values
        
        Parameters
        ----------
        tb  : brightness temperatures
        lat : latitudes of tb values
    
        Returns
        -------
        Ta: np.array [n x 4], antenna weighted TB for 4 GMI channels
    
        """


        Ta = []
        for i in range(tb.shape[1]):
            ta = apply_gaussfilter(lat, tb[:, i], 6/111)# 6km smoothing
            Ta.append(ta) 
                    
        Ta = np.concatenate(Ta, axis = 1) 
        return Ta  
    
    
    @property
    def tb(self):
        """
        brightness temperatures
        
        Tb values, one column per position. Rows match (in order):
                 166V, 166H, 183.31+-7V, 183.31+-3V


        Returns
        -------
        np.array of TB values

        """
        tb = self.get_data('Tb')
        tb = np.concatenate(tb, axis = 0)
        return np.squeeze(tb)

    @property
    def ta(self):
        """
        antenna weighted brightness temperatures
        
        Ta values, one column per position. Rows match (in order):
                 166V, 166H, 183.31+-7V, 183.31+-3V

        Returns
        -------
        np.array of TB values

        """
        ta = self.get_data('Ta')
        ta = np.concatenate(ta, axis = 0)
        return np.squeeze(ta)

    @property
    def ta_noise(self):
        """
        antenna weighted brightness temperatures with gaussian noise
        
        one column per position. Rows match (in order):
                 166V, 166H, 183.31+-7V, 183.31+-3V
        Returns
        -------
        np.array of TB values

        """
        nedt = np.array([0.70, 0.65, 0.47, 0.56 ])
        ta = self.get_data('Ta')
        ta = np.squeeze(np.concatenate(ta, axis = 0))
        

        ta = add_gaussian_noise(ta, nedt)
        
        return ta
    
    @property
    def iwp(self):
        """
        ice water path

        Returns
        -------
        np.array of IWP values

        """
        
        iwp = self.get_data('iwp')
        iwp = np.concatenate(iwp, axis = 0)
        return iwp.ravel()
    
    
    @property
    def wvp(self):
        """
        water vapour path

        Returns
        -------
        np.array of IWP values

        """
        
        wvp = self.get_data('wvp')
        wvp = np.concatenate(wvp, axis = 0)
        return wvp.ravel()
 
    @property
    def rwp(self):
        """
        rain water  path

        Returns
        -------
        np.array of RWP values

        """
        
        rwp = self.get_data('rwp')
        rwp = np.concatenate(rwp, axis = 0)
        return rwp.ravel()   

    @property
    def t0(self):
        """
        surface temperature

        Returns
        -------
        np.array of t0 values

        """
        
        t0 = self.get_data('t0')
        t0 = np.concatenate(t0, axis = 0)
        return t0.ravel() 
 
    @property
    def p0(self):
        """
        surface pressure

        Returns
        -------
        np.array of t0 values

        """
        
        p0 = self.get_data('p0')
        p0 = np.concatenate(p0, axis = 0)
        return p0.ravel() 
    
    @property
    def z0(self):
        """
        surface altitude

        Returns
        -------
        np.array of z0 values

        """
        
        z0 = self.get_data('z0')
        z0 = np.concatenate(z0, axis = 0)
        return z0.ravel()     

    @property
    def lat(self):
        """
        latitudes

        Returns
        -------
        np.array of lat values

        """
        
        lat = self.get_data('lat')
        if len(lat)==1:
            return np.array(lat).ravel()
        else:
            return np.concatenate(lat, axis = 0).ravel()
        
    @property
    def lon(self):
        """
        latitudes

        Returns
        -------
        np.array of lat values

        """
        
        lon = self.get_data('lon')
        if len(lon)==1:
            return np.array(lon).ravel()
        else:
            return np.concatenate(lon, axis = 0).ravel()

    @property
    def t2m(self):
        """
        2m temperature

        Returns
        -------
        np.array of t2m values

        """
        
        t2m = self.get_data('t2m')
        if len(t2m)==1:
            return np.array(t2m).ravel()
        else:
            return np.concatenate(t2m, axis = 0).ravel()    
 
    @property
    def incang(self):
        """
        incidence angle

        Returns
        -------
        np.array of incidence angle values

        """
        
        incang = self.get_data('incang')
        if len(incang)==1:
            return np.array(incang).ravel()
        else:
            return np.concatenate(incang, axis = 0).ravel()    

    @property
    def e166h(self):
        """
        emissivities, 166 GHz H polarisation

        Returns
        -------
        np.array of incidence angle values

        """
        
        e166h = self.get_data('e166h')
        if len(e166h)==1:
            return np.array(e166h).ravel()
        else:
            return np.concatenate(e166h, axis = 0).ravel()   

    @property
    def e166v(self):
        """
        emissivities, 166 GHz V polarisation

        Returns
        -------
        np.array of incidence angle values

        """
        
        e166v = self.get_data('e166v')
        if len(e166v)==1:
            return np.array(e166v).ravel()
        else:
            return np.concatenate(e166v, axis = 0).ravel()    

    @property
    def e183v(self):
        """
        emissivities, 183 GHz V polarisation

        Returns
        -------
        np.array of incidence angle values

        """
        
        e183v = self.get_data('e183v')
        if len(e183v)==1:
            return np.array(e183v).ravel()
        else:
            return np.concatenate(e183v, axis = 0).ravel()  
        
    @property
    def e183h(self):
        """
        emissivities, 183 GHz H polarisation

        Returns
        -------
        np.array of incidence angle values

        """
        
        e183h = self.get_data('e183h')
        if len(e183h)==1:
            return np.array(e183h).ravel()
        else:
            return np.concatenate(e183h, axis = 0).ravel()            
       
    @property
    def skt(self):
        """
        skin temperature

        Returns
        -------
        np.array of skt values

        """
        
        skt = self.get_data('tskin')
        if len(skt)==1:
            return np.array(skt).ravel()
        else:
            return np.concatenate(skt, axis = 0).ravel()   
         
    @property
    def stype(self):
        """
        latitudes

        Returns
        -------
        np.array of lat values

        """
        stype = self.get_lsm()
        if len(stype) == 1:
            return np.array(stype).ravel()
        else:
            return  np.concatenate(stype, axis = 0)  
    
    
    def pdf(self, bins = None, plot = True):
        """
        generates pdf of Tb from IceCube simulations

        These are not antenna weighted,
        Just to make a quick check.
        Parameters
        ----------
        bins : np.array, optional
            intervals over which PDF is to be computed. The default is None.
            When None, default bins used are np.arange(100, 300, 0.5)
        plot : boolean, optional
            if true, generates a plot of the PDF. The default is True.

        Returns
        -------
        hist[0] : np.array, The values of the histogram

        """
        
        tb = self.tb
        

        bins = np.arange(100, 310, 1)
        fig, ax = plt.subplots(1,1, figsize = [8, 8])
        
        for i in range(4):
        
            hist = np.histogram(tb[:, i], bins, density = True)
        
            if plot:
            

                ax.plot(bins[:-1], hist[0], label = i)
                ax.set_yscale('log')
                ax.set_ylabel('PDF [#/K]')
                ax.set_xlabel('TB [K]')
                ax.legend()
        return hist[0]
    



    
